<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minecraft JS: Menu & Hotbar</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Courier New', monospace; user-select: none; }
        
        /* UI OVERLAY */
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.9); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
        }
        
        #hotbar {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0, 0, 0, 0.5); padding: 5px;
            border-radius: 5px; pointer-events: none;
        }
        .slot {
            width: 40px; height: 40px; border: 2px solid #555; background: rgba(0,0,0,0.3);
            color: white; font-size: 24px; text-align: center; line-height: 40px;
            font-weight: bold;
        }
        .active { border-color: white; background: rgba(255,255,255,0.2); }

        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20;
            color: white;
        }
        #menu h1 { margin-bottom: 20px; text-shadow: 2px 2px #000; }
        .btn {
            background: #4CAF50; color: white; border: none; padding: 15px 32px;
            text-align: center; font-size: 16px; margin: 10px; cursor: pointer;
            border: 2px solid #fff; width: 200px;
        }
        .btn:hover { background: #45a049; }
        
        /* Hide menu initially if desired, but we start paused */
        .hidden { display: none !important; }
        
        #debug { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.5); padding: 5px; }
    </style>
</head>
<body>

    <div id="crosshair"></div>
    <div id="debug">Chunks: 0</div>

    <div id="hotbar">
        <div class="slot active" id="slot1">1</div> <div class="slot" id="slot2">2</div> <div class="slot" id="slot3">3</div> <div class="slot" id="slot4">4</div> </div>

    <div id="menu">
        <h1>PAUSED</h1>
        <button class="btn" id="resumeBtn">Resume Game</button>
        <button class="btn" onclick="location.reload()">Regenerate World</button>
        <p>WASD to Move | SPACE Jump | 1-4 Select Block | Click to Mine/Place</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "simplex-noise": "https://unpkg.com/simplex-noise@4.0.1/dist/esm/simplex-noise.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { createNoise2D } from 'simplex-noise';

        // --- CONFIG ---
        const CHUNK_SIZE = 16;
        const WORLD_HEIGHT = 32;
        const RENDER_DISTANCE = 2;

        // Texture URLs
        const TEX_URLS = {
            grassTop: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/grass.png',
            grassSide: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/grass_dirt.png',
            dirt: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/dirt.png',
            stone: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/cobblestone.png',
            brick: 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/minecraft/brick_diffuse.jpg'
        };

        // --- GLOBALS ---
        let camera, scene, renderer, raycaster;
        let chunks = {};
        const noise2D = createNoise2D();
        let materials = [];
        let isPaused = true;

        // Player State
        const velocity = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        let selectedBlockType = 1; // Default Grass

        init();

        async function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 10, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';
            camera.position.set(0, 20, 0);

            // 1. Load Textures with Fallback Color
            const loader = new THREE.TextureLoader();
            const loadTex = (url) => {
                const tex = loader.load(url);
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestFilter;
                tex.colorSpace = THREE.SRGBColorSpace;
                return tex;
            };

            // Material Array: 0=GrassTop, 1=GrassSide, 2=Dirt, 3=Stone, 4=Brick
            materials = [
                new THREE.MeshLambertMaterial({ map: loadTex(TEX_URLS.grassTop), color: 0xeeeeee }),
                new THREE.MeshLambertMaterial({ map: loadTex(TEX_URLS.grassSide), color: 0xeeeeee }),
                new THREE.MeshLambertMaterial({ map: loadTex(TEX_URLS.dirt), color: 0xeeeeee }),
                new THREE.MeshLambertMaterial({ map: loadTex(TEX_URLS.stone), color: 0xeeeeee }),
                new THREE.MeshLambertMaterial({ map: loadTex(TEX_URLS.brick), color: 0xeeeeee })
            ];

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(50, 100, 50);
            scene.add(dirLight);

            // Inputs
            setupInputs();
            setupMenu();

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize);

            // Generate World
            await updateChunks();

            // Loop
            animate();
        }

        // --- MENU & UI HANDLERS ---
        function setupMenu() {
            const menu = document.getElementById('menu');
            const resumeBtn = document.getElementById('resumeBtn');
            
            // Resume Button
            resumeBtn.addEventListener('click', () => {
                document.body.requestPointerLock();
            });

            // Pointer Lock Event
            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === document.body) {
                    isPaused = false;
                    menu.classList.add('hidden');
                } else {
                    isPaused = true;
                    menu.classList.remove('hidden');
                }
            });
        }

        function updateHotbarUI(index) {
            // index 1-4
            document.querySelectorAll('.slot').forEach(el => el.classList.remove('active'));
            document.getElementById(`slot${index}`).classList.add('active');
        }

        // --- CHUNK SYSTEM ---
        function getChunkKey(cx, cz) { return `${cx},${cz}`; }

        function getBlockGlobal(x, y, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const chunk = chunks[getChunkKey(cx, cz)];
            if (!chunk) return 0;
            let lx = x % CHUNK_SIZE;
            let lz = z % CHUNK_SIZE;
            if (lx < 0) lx += CHUNK_SIZE;
            if (lz < 0) lz += CHUNK_SIZE;
            if (y < 0 || y >= WORLD_HEIGHT) return 0;
            return chunk.data[lx][y][lz];
        }

        async function updateChunks() {
            const playerCX = Math.floor(camera.position.x / CHUNK_SIZE);
            const playerCZ = Math.floor(camera.position.z / CHUNK_SIZE);

            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                for (let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                    const cx = playerCX + x;
                    const cz = playerCZ + z;
                    const key = getChunkKey(cx, cz);
                    if (!chunks[key]) {
                        chunks[key] = {
                            data: generateChunkData(cx, cz),
                            cx: cx, cz: cz, mesh: null
                        };
                        rebuildChunkMesh(chunks[key]);
                    }
                }
            }
            document.getElementById('debug').innerText = `Chunks: ${Object.keys(chunks).length} | Block: ${selectedBlockType}`;
        }

        function generateChunkData(cx, cz) {
            const data = [];
            for (let x = 0; x < CHUNK_SIZE; x++) {
                data[x] = [];
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    data[x][y] = [];
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const globalX = (cx * CHUNK_SIZE) + x;
                        const globalZ = (cz * CHUNK_SIZE) + z;
                        const noiseVal = noise2D(globalX / 30, globalZ / 30);
                        const height = Math.floor((noiseVal + 1) * 6 + 4);
                        
                        let type = 0;
                        if (y < height) {
                            if (y === height - 1) type = 1; // Grass
                            else if (y > height - 4) type = 2; // Dirt
                            else type = 3; // Stone
                        }
                        data[x][y][z] = type;
                    }
                }
            }
            return data;
        }

        function rebuildChunkMesh(chunk) {
            if (chunk.mesh) {
                scene.remove(chunk.mesh);
                chunk.mesh.geometry.dispose();
            }

            // Buckets: 0=GrassTop, 1=GrassSide, 2=Dirt, 3=Stone, 4=Brick
            const matGeom = [[], [], [], [], []];

            const addFace = (x, y, z, matIndex, faceType) => {
                const X = x, Y = y, Z = z;
                let v = [];
                // Fixed Winding Order: Counter-Clockwise
                if (faceType === 0) v = [X+1,Y,Z+1, X+1,Y,Z, X+1,Y+1,Z, X+1,Y+1,Z+1]; // Right
                else if (faceType === 1) v = [X,Y,Z, X,Y,Z+1, X,Y+1,Z+1, X,Y+1,Z]; // Left
                else if (faceType === 2) v = [X,Y+1,Z+1, X+1,Y+1,Z+1, X+1,Y+1,Z, X,Y+1,Z]; // Top
                else if (faceType === 3) v = [X,Y,Z, X+1,Y,Z, X+1,Y,Z+1, X,Y,Z+1]; // Bottom
                else if (faceType === 4) v = [X,Y,Z+1, X+1,Y,Z+1, X+1,Y+1,Z+1, X,Y+1,Z+1]; // Front
                else if (faceType === 5) v = [X+1,Y,Z, X,Y,Z, X,Y+1,Z, X+1,Y+1,Z]; // Back

                // Safety: Ensure material index exists
                if(matGeom[matIndex]) {
                    for(let k=0; k<v.length; k++) matGeom[matIndex].push(v[k]);
                }
            };

            for (let x = 0; x < CHUNK_SIZE; x++) {
                for (let y = 0; y < WORLD_HEIGHT; y++) {
                    for (let z = 0; z < CHUNK_SIZE; z++) {
                        const type = chunk.data[x][y][z];
                        if (type === 0) continue;
                        
                        const gx = (chunk.cx * CHUNK_SIZE) + x;
                        const gy = y;
                        const gz = (chunk.cz * CHUNK_SIZE) + z;

                        // Texture Mapping Logic
                        let side=2, top=2, bot=2;

                        if (type === 1) { // Grass Block
                            top = 0; side = 1; bot = 2;
                        } else if (type === 2) { // Dirt
                            top = 2; side = 2; bot = 2;
                        } else if (type === 3) { // Stone
                            top = 3; side = 3; bot = 3;
                        } else if (type === 4) { // Brick
                            top = 4; side = 4; bot = 4;
                        }

                        if (getBlockGlobal(gx+1, gy, gz) === 0) addFace(x,y,z, side, 0);
                        if (getBlockGlobal(gx-1, gy, gz) === 0) addFace(x,y,z, side, 1);
                        if (getBlockGlobal(gx, gy+1, gz) === 0) addFace(x,y,z, top, 2);
                        if (getBlockGlobal(gx, gy-1, gz) === 0) addFace(x,y,z, bot, 3);
                        if (getBlockGlobal(gx, gy, gz+1) === 0) addFace(x,y,z, side, 4);
                        if (getBlockGlobal(gx, gy, gz-1) === 0) addFace(x,y,z, side, 5);
                    }
                }
            }

            const geometry = new THREE.BufferGeometry();
            const allVertices = [];
            const allUVs = [];
            let currentIndex = 0;

            for (let m = 0; m < materials.length; m++) {
                const verts = matGeom[m];
                if (verts.length === 0) continue;
                allVertices.push(...verts);
                for (let i = 0; i < verts.length / 12; i++) {
                    allUVs.push(0,0, 1,0, 1,1, 0,1);
                }
                const numIndices = (verts.length / 12) * 6;
                geometry.addGroup(currentIndex, numIndices, m);
                currentIndex += numIndices;
            }

            const allIndices = [];
            for (let i = 0; i < allVertices.length / 12; i++) {
                const base = i * 4;
                allIndices.push(base, base+1, base+2);
                allIndices.push(base, base+2, base+3);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(allVertices, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(allUVs, 2));
            geometry.setIndex(allIndices);
            geometry.computeVertexNormals();

            chunk.mesh = new THREE.Mesh(geometry, materials);
            chunk.mesh.position.set(chunk.cx * CHUNK_SIZE, 0, chunk.cz * CHUNK_SIZE);
            scene.add(chunk.mesh);
        }

        // --- INPUTS ---
        function setupInputs() {
            document.addEventListener('keydown', (e) => {
                if (isPaused) return;

                if(e.code === 'KeyW') moveForward = true;
                if(e.code === 'KeyA') moveLeft = true;
                if(e.code === 'KeyS') moveBackward = true;
                if(e.code === 'KeyD') moveRight = true;
                if(e.code === 'Space' && !canJump) { velocity.y += 12; canJump = true; }
                
                // Hotbar Selection
                if(e.key === '1') { selectedBlockType = 1; updateHotbarUI(1); } // Grass
                if(e.key === '2') { selectedBlockType = 2; updateHotbarUI(2); } // Dirt
                if(e.key === '3') { selectedBlockType = 3; updateHotbarUI(3); } // Stone
                if(e.key === '4') { selectedBlockType = 4; updateHotbarUI(4); } // Brick
            });
            
            document.addEventListener('keyup', (e) => {
                if(e.code === 'KeyW') moveForward = false;
                if(e.code === 'KeyA') moveLeft = false;
                if(e.code === 'KeyS') moveBackward = false;
                if(e.code === 'KeyD') moveRight = false;
            });

            document.addEventListener('mousemove', (event) => {
                if (!isPaused) {
                    camera.rotation.y -= event.movementX * 0.002;
                    camera.rotation.x -= event.movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });

            raycaster = new THREE.Raycaster();
            document.addEventListener('mousedown', (event) => {
                if (isPaused) return;
                
                raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                const meshes = Object.values(chunks).map(c => c.mesh).filter(m => m);
                const intersects = raycaster.intersectObjects(meshes);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const p = hit.point;
                    const n = hit.face.normal;
                    
                    const bx = Math.floor(p.x - n.x * 0.1);
                    const by = Math.floor(p.y - n.y * 0.1);
                    const bz = Math.floor(p.z - n.z * 0.1);

                    if (event.button === 0) { // Left Click: Break
                        setBlockGlobal(bx, by, bz, 0); 
                    } else if (event.button === 2) { // Right Click: Place
                        const px = Math.floor(p.x + n.x * 0.1);
                        const py = Math.floor(p.y + n.y * 0.1);
                        const pz = Math.floor(p.z + n.z * 0.1);
                        
                        const dist = new THREE.Vector3(px+0.5, py+0.5, pz+0.5).distanceTo(camera.position);
                        if(dist > 1.2) {
                            // Place the CURRENTLY SELECTED block
                            setBlockGlobal(px, py, pz, selectedBlockType); 
                        }
                    }
                }
            });
        }

        function setBlockGlobal(x, y, z, type) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const key = getChunkKey(cx, cz);
            if (!chunks[key]) return;

            let lx = x % CHUNK_SIZE;
            let lz = z % CHUNK_SIZE;
            if (lx < 0) lx += CHUNK_SIZE;
            if (lz < 0) lz += CHUNK_SIZE;

            chunks[key].data[lx][y][lz] = type;
            rebuildChunkMesh(chunks[key]);
            
            // Rebuild neighbors if edge
            if(lx===0) rebuildChunkMesh(chunks[getChunkKey(cx-1, cz)]);
            if(lx===CHUNK_SIZE-1) rebuildChunkMesh(chunks[getChunkKey(cx+1, cz)]);
            if(lz===0) rebuildChunkMesh(chunks[getChunkKey(cx, cz-1)]);
            if(lz===CHUNK_SIZE-1) rebuildChunkMesh(chunks[getChunkKey(cx, cz+1)]);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (isPaused) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            prevTime = time;

            const speed = 6.0;
            velocity.x = 0; velocity.z = 0;

            if (moveForward) {
                velocity.z -= speed * Math.cos(camera.rotation.y);
                velocity.x -= speed * Math.sin(camera.rotation.y);
            }
            if (moveBackward) {
                velocity.z += speed * Math.cos(camera.rotation.y);
                velocity.x += speed * Math.sin(camera.rotation.y);
            }
            if (moveLeft) {
                velocity.x -= speed * Math.cos(camera.rotation.y);
                velocity.z += speed * Math.sin(camera.rotation.y);
            }
            if (moveRight) {
                velocity.x += speed * Math.cos(camera.rotation.y);
                velocity.z -= speed * Math.sin(camera.rotation.y);
            }

            velocity.y -= 30.0 * delta; 
            camera.position.x += velocity.x * delta;
            camera.position.z += velocity.z * delta;
            camera.position.y += velocity.y * delta;

            const groundHeight = getTerrainHeight(camera.position.x, camera.position.z);
            if (camera.position.y < groundHeight + 1.8) {
                camera.position.y = groundHeight + 1.8;
                velocity.y = 0;
                canJump = false;
            }
            updateChunks();
            renderer.render(scene, camera);
        }

        function getTerrainHeight(x, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            const chunk = chunks[getChunkKey(cx, cz)];
            if(!chunk) return 0;
            let lx = Math.floor(x) % CHUNK_SIZE;
            let lz = Math.floor(z) % CHUNK_SIZE;
            if(lx < 0) lx += CHUNK_SIZE;
            if(lz < 0) lz += CHUNK_SIZE;
            for(let y=WORLD_HEIGHT-1; y>=0; y--) {
                if(chunk.data[lx][y][lz] !== 0) return y + 1;
            }
            return 0;
        }
    </script>
</body>
</html>