<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logic Gate Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 24px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .gate-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .gate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .gate-btn.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.5);
        }

        .help-btn {
            background: #2ecc71;
            color: white;
        }

        .help-btn:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }

        .clear-btn {
            background: #e74c3c;
            color: white;
        }

        .clear-btn:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .example-btn {
            background: #9b59b6;
            color: white;
        }

        .example-btn:hover {
            background: #8e44ad;
            transform: translateY(-2px);
        }

        .clock-btn {
            background: #3498db;
            color: white;
        }

        .clock-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .clock-btn.running {
            background: #e67e22;
        }

        .canvas-container {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            cursor: crosshair;
            display: block;
            margin: 0 auto;
            background: #0f0f0f;
        }

        canvas.moving {
            cursor: move;
        }

        canvas.wiring {
            cursor: crosshair;
        }

        .info-panel {
            background: #1a1a1a;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }

        .info-panel h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background: #1a1a1a;
            margin: 5% auto;
            padding: 30px;
            border-radius: 16px;
            width: 90%;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.9);
            border: 1px solid #333;
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 32px;
            font-weight: bold;
            cursor: pointer;
            line-height: 20px;
        }

        .close:hover {
            color: #fff;
        }

        .modal-content h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        .modal-content h3 {
            color: #764ba2;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        .modal-content ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        .modal-content li {
            margin-bottom: 8px;
        }

        .gate-info {
            background: #0a0a0a;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.8em;
            }
            
            .controls {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>âš¡ Logic Gate Simulator</h1>
            <p>Build and test digital logic circuits</p>
        </header>

        <div class="controls">
            <button class="gate-btn" onclick="selectGate('AND')">AND Gate</button>
            <button class="gate-btn" onclick="selectGate('OR')">OR Gate</button>
            <button class="gate-btn" onclick="selectGate('NOT')">NOT Gate</button>
            <button class="gate-btn" onclick="selectGate('NAND')">NAND Gate</button>
            <button class="gate-btn" onclick="selectGate('NOR')">NOR Gate</button>
            <button class="gate-btn" onclick="selectGate('XOR')">XOR Gate</button>
            <button class="gate-btn" onclick="selectGate('INPUT')">Add Input</button>
            <button class="gate-btn" onclick="selectGate('OUTPUT')">Add Output</button>
            <button class="gate-btn" id="selectBtn" onclick="selectMode()">Select/Move</button>
            <button class="example-btn" onclick="loadHalfAdder()">Load Half-Adder</button>
            <button class="clock-btn" id="clockBtn" onclick="toggleClock()">Start Clock</button>
            <button class="help-btn" onclick="showHelp()">How to Use</button>
            <button class="clear-btn" onclick="clearAll()">Clear All</button>
        </div>

        <div class="info-panel">
            <h3>Current Tool: <span id="currentTool">None</span></h3>
            <p id="instructions">Select a gate or input to place on the canvas</p>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="1000" height="600"></canvas>
        </div>
    </div>

    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeHelp()">&times;</span>
            <h2>ðŸ“š How to Use the Logic Gate Simulator</h2>
            
            <h3>Getting Started:</h3>
            <ul>
                <li><strong>Select a Tool:</strong> Click any button in the control panel to select a gate or input</li>
                <li><strong>Place Components:</strong> Click on the canvas to place the selected component</li>
                <li><strong>Move Components:</strong> Click "Select/Move", then drag components to reposition them</li>
                <li><strong>Connect with Wires:</strong> In Select/Move mode, click and drag from an output (right side) to an input (left side)</li>
                <li><strong>Toggle Inputs:</strong> Click on input switches (circles) to toggle between 0 and 1</li>
                <li><strong>Delete Components:</strong> Press Delete or Backspace while hovering over a component in Select/Move mode</li>
                <li><strong>Clear Canvas:</strong> Use the "Clear All" button to start over</li>
            </ul>

            <h3>Logic Gates:</h3>
            <div class="gate-info">
                <strong>AND Gate:</strong> Output is 1 only when both inputs are 1
            </div>
            <div class="gate-info">
                <strong>OR Gate:</strong> Output is 1 when at least one input is 1
            </div>
            <div class="gate-info">
                <strong>NOT Gate:</strong> Inverts the input (0â†’1, 1â†’0)
            </div>
            <div class="gate-info">
                <strong>NAND Gate:</strong> Opposite of AND (output is 0 only when both inputs are 1)
            </div>
            <div class="gate-info">
                <strong>NOR Gate:</strong> Opposite of OR (output is 1 only when both inputs are 0)
            </div>
            <div class="gate-info">
                <strong>XOR Gate:</strong> Output is 1 when inputs are different
            </div>

            <h3>Inputs and Outputs:</h3>
            <div class="gate-info">
                <strong>INPUT:</strong> Toggle-able switch that provides 0 or 1 to your circuit
            </div>
            <div class="gate-info">
                <strong>OUTPUT:</strong> Displays the final result from your circuit (lights up when receiving 1)
            </div>

            <h3>Connection Points:</h3>
            <ul>
                <li><strong>Outputs:</strong> Small circles on the right side of components (where signal comes out)</li>
                <li><strong>Inputs:</strong> Small circles on the left side of gates (where signal goes in)</li>
                <li>Wire colors: Red = 0 (false), Green = 1 (true), Gray = no signal</li>
            </ul>

            <h3>Tips:</h3>
            <ul>
                <li>Use Select/Move mode to organize your circuit layout</li>
                <li>Click and drag to create wires between components</li>
                <li>Build circuits like half-adders, full-adders, or multiplexers!</li>
                <li>The output values update automatically when you toggle inputs</li>
                <li>Try the "Load Half-Adder" button to see an example circuit</li>
                <li>Use the clock to automatically toggle an input on/off</li>
            </ul>

            <h3>What's a Half-Adder?</h3>
            <div class="gate-info">
                A half-adder adds two single binary digits (A and B) and produces a Sum and a Carry output. It uses one XOR gate for the Sum (A âŠ• B) and one AND gate for the Carry (A Â· B). This is a fundamental building block in digital arithmetic circuits!
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let selectedTool = null;
        let components = [];
        let wires = [];
        let nextId = 0;
        let draggedComponent = null;
        let dragOffset = { x: 0, y: 0 };
        let wireStart = null;
        let wireDragPos = null;
        let hoveredComponent = null;
        let clockInterval = null;
        let clockRunning = false;
        let clockInput = null;

        function selectGate(type) {
            selectedTool = type;
            wireStart = null;
            wireDragPos = null;
            
            document.querySelectorAll('.gate-btn').forEach(btn => btn.classList.remove('active'));
            
            document.getElementById('currentTool').textContent = type;
            document.getElementById('instructions').textContent = 'Click on the canvas to place the ' + type;
            canvas.classList.remove('moving', 'wiring');
        }

        function selectMode() {
            selectedTool = 'SELECT';
            wireStart = null;
            wireDragPos = null;
            
            document.querySelectorAll('.gate-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('selectBtn').classList.add('active');
            
            document.getElementById('currentTool').textContent = 'SELECT/MOVE';
            document.getElementById('instructions').textContent = 'Click and drag to move components or create wires';
            canvas.classList.remove('wiring');
        }

        function showHelp() {
            document.getElementById('helpModal').style.display = 'block';
        }

        function closeHelp() {
            document.getElementById('helpModal').style.display = 'none';
        }

        window.onclick = function(e) {
            const modal = document.getElementById('helpModal');
            if (e.target === modal) {
                closeHelp();
            }
        }

        function clearAll() {
            components = [];
            wires = [];
            wireStart = null;
            wireDragPos = null;
            draggedComponent = null;
            stopClock();
            draw();
        }

        function loadHalfAdder() {
            clearAll();
            
            // Create inputs A and B
            const inputA = {
                id: nextId++,
                type: 'INPUT',
                x: 150,
                y: 200,
                value: 0
            };
            
            const inputB = {
                id: nextId++,
                type: 'INPUT',
                x: 150,
                y: 350,
                value: 0
            };
            
            // Create XOR gate for Sum
            const xorGate = {
                id: nextId++,
                type: 'XOR',
                x: 400,
                y: 275,
                value: null
            };
            
            // Create AND gate for Carry
            const andGate = {
                id: nextId++,
                type: 'AND',
                x: 400,
                y: 400,
                value: null
            };
            
            // Create Sum output
            const sumOutput = {
                id: nextId++,
                type: 'OUTPUT',
                x: 650,
                y: 275,
                value: null
            };
            
            // Create Carry output
            const carryOutput = {
                id: nextId++,
                type: 'OUTPUT',
                x: 650,
                y: 400,
                value: null
            };
            
            components.push(inputA, inputB, xorGate, andGate, sumOutput, carryOutput);
            
            // Wire input A to XOR (top input)
            wires.push({
                from: inputA,
                to: xorGate,
                toIndex: 0
            });
            
            // Wire input B to XOR (bottom input)
            wires.push({
                from: inputB,
                to: xorGate,
                toIndex: 1
            });
            
            // Wire input A to AND (top input)
            wires.push({
                from: inputA,
                to: andGate,
                toIndex: 0
            });
            
            // Wire input B to AND (bottom input)
            wires.push({
                from: inputB,
                to: andGate,
                toIndex: 1
            });
            
            // Wire XOR output to Sum output
            wires.push({
                from: xorGate,
                to: sumOutput,
                toIndex: 0
            });
            
            // Wire AND output to Carry output
            wires.push({
                from: andGate,
                to: carryOutput,
                toIndex: 0
            });
            
            updateOutputs();
            draw();
            
            selectedTool = 'SELECT';
            document.querySelectorAll('.gate-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('selectBtn').classList.add('active');
            document.getElementById('currentTool').textContent = 'SELECT/MOVE';
            document.getElementById('instructions').textContent = 'Half-Adder loaded! Click the inputs to toggle them and see how addition works. Top output is SUM, bottom is CARRY.';
        }

        function toggleClock() {
            if (clockRunning) {
                stopClock();
            } else {
                startClock();
            }
        }

        function startClock() {
            // Find the first input to use as clock
            clockInput = components.find(c => c.type === 'INPUT');
            
            if (!clockInput) {
                alert('Please add at least one INPUT component first!');
                return;
            }
            
            clockRunning = true;
            document.getElementById('clockBtn').textContent = 'Stop Clock';
            document.getElementById('clockBtn').classList.add('running');
            
            clockInterval = setInterval(() => {
                if (clockInput && components.includes(clockInput)) {
                    clockInput.value = clockInput.value === 1 ? 0 : 1;
                    updateOutputs();
                    draw();
                } else {
                    stopClock();
                }
            }, 1000);
        }

        function stopClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
            clockRunning = false;
            clockInput = null;
            document.getElementById('clockBtn').textContent = 'Start Clock';
            document.getElementById('clockBtn').classList.remove('running');
        }

        function getConnectionPoint(comp, isOutput, index = 0) {
            if (comp.type === 'INPUT') {
                return { x: comp.x + 20, y: comp.y };
            } else if (comp.type === 'OUTPUT') {
                return { x: comp.x - 20, y: comp.y };
            } else if (comp.type === 'NOT') {
                if (isOutput) {
                    return { x: comp.x + 40, y: comp.y };
                } else {
                    return { x: comp.x - 40, y: comp.y };
                }
            } else {
                if (isOutput) {
                    return { x: comp.x + 40, y: comp.y };
                } else {
                    const offsetY = index === 0 ? -12 : 12;
                    return { x: comp.x - 40, y: comp.y + offsetY };
                }
            }
        }

        function findClickedConnection(x, y) {
            for (let comp of components) {
                // Check outputs (INPUT and gate outputs)
                if (comp.type !== 'OUTPUT') {
                    const output = getConnectionPoint(comp, true);
                    const dist = Math.sqrt((x - output.x) ** 2 + (y - output.y) ** 2);
                    if (dist < 8) {
                        return { component: comp, isOutput: true, index: 0 };
                    }
                }

                // Check inputs (gate inputs and OUTPUT inputs)
                if (comp.type !== 'INPUT') {
                    const numInputs = (comp.type === 'NOT' || comp.type === 'OUTPUT') ? 1 : 2;
                    for (let i = 0; i < numInputs; i++) {
                        const input = getConnectionPoint(comp, false, i);
                        const dist = Math.sqrt((x - input.x) ** 2 + (y - input.y) ** 2);
                        if (dist < 8) {
                            return { component: comp, isOutput: false, index: i };
                        }
                    }
                }
            }
            return null;
        }

        function findComponentAt(x, y) {
            for (let i = components.length - 1; i >= 0; i--) {
                const comp = components[i];
                if (comp.type === 'INPUT' || comp.type === 'OUTPUT') {
                    const dist = Math.sqrt((x - comp.x) ** 2 + (y - comp.y) ** 2);
                    if (dist < 20) return comp;
                } else {
                    if (x >= comp.x - 40 && x <= comp.x + 40 &&
                        y >= comp.y - 25 && y <= comp.y + 25) {
                        return comp;
                    }
                }
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (selectedTool === 'SELECT') {
                const conn = findClickedConnection(x, y);
                if (conn && conn.isOutput) {
                    wireStart = conn;
                    wireDragPos = { x, y };
                    canvas.classList.add('wiring');
                    return;
                }

                const comp = findComponentAt(x, y);
                if (comp) {
                    if (comp.type === 'INPUT') {
                        const dist = Math.sqrt((x - comp.x) ** 2 + (y - comp.y) ** 2);
                        if (dist < 15) {
                            comp.value = comp.value === 1 ? 0 : 1;
                            updateOutputs();
                            draw();
                            return;
                        }
                    }
                    draggedComponent = comp;
                    dragOffset = { x: x - comp.x, y: y - comp.y };
                    canvas.classList.add('moving');
                }
                return;
            }

            if (!selectedTool) return;

            const comp = findComponentAt(x, y);
            if (comp && comp.type === 'INPUT') {
                comp.value = comp.value === 1 ? 0 : 1;
                updateOutputs();
                draw();
                return;
            }

            const component = {
                id: nextId++,
                type: selectedTool,
                x: x,
                y: y,
                value: selectedTool === 'INPUT' ? 0 : null
            };

            components.push(component);
            draw();
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (draggedComponent) {
                draggedComponent.x = x - dragOffset.x;
                draggedComponent.y = y - dragOffset.y;
                updateOutputs();
                draw();
                return;
            }

            if (wireStart && wireDragPos) {
                wireDragPos = { x, y };
                draw();
                return;
            }

            if (selectedTool === 'SELECT') {
                hoveredComponent = findComponentAt(x, y);
                draw();
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (wireStart && wireDragPos) {
                const conn = findClickedConnection(x, y);
                if (conn && !conn.isOutput && conn.component !== wireStart.component) {
                    wires.push({
                        from: wireStart.component,
                        to: conn.component,
                        toIndex: conn.index
                    });
                    updateOutputs();
                }
                wireStart = null;
                wireDragPos = null;
                canvas.classList.remove('wiring');
                draw();
                return;
            }

            if (draggedComponent) {
                draggedComponent = null;
                canvas.classList.remove('moving');
            }
        });

        canvas.addEventListener('mouseleave', () => {
            if (wireStart) {
                wireStart = null;
                wireDragPos = null;
                canvas.classList.remove('wiring');
                draw();
            }
        });

        document.addEventListener('keydown', (e) => {
            if ((e.key === 'Delete' || e.key === 'Backspace') && selectedTool === 'SELECT' && hoveredComponent) {
                e.preventDefault();
                components = components.filter(c => c !== hoveredComponent);
                wires = wires.filter(w => w.from !== hoveredComponent && w.to !== hoveredComponent);
                hoveredComponent = null;
                updateOutputs();
                draw();
            }
        });

        function updateOutputs() {
            for (let comp of components) {
                if (comp.type !== 'INPUT') {
                    comp.value = null;
                }
            }

            let changed = true;
            let iterations = 0;
            while (changed && iterations < 100) {
                changed = false;
                iterations++;

                for (let comp of components) {
                    if (comp.type === 'INPUT') continue;

                    const inputWires = wires.filter(w => w.to === comp);
                    if (inputWires.length === 0) continue;

                    const inputs = [];
                    const numInputs = (comp.type === 'NOT' || comp.type === 'OUTPUT') ? 1 : 2;
                    
                    for (let i = 0; i < numInputs; i++) {
                        const wire = inputWires.find(w => w.toIndex === i);
                        if (wire && wire.from.value !== null) {
                            inputs[i] = wire.from.value;
                        } else {
                            inputs[i] = null;
                        }
                    }

                    const hasAllInputs = inputs.every(v => v !== null);
                    if (!hasAllInputs) continue;

                    let newValue = null;
                    switch(comp.type) {
                        case 'AND':
                            newValue = (inputs[0] && inputs[1]) ? 1 : 0;
                            break;
                        case 'OR':
                            newValue = (inputs[0] || inputs[1]) ? 1 : 0;
                            break;
                        case 'NOT':
                            newValue = inputs[0] ? 0 : 1;
                            break;
                        case 'NAND':
                            newValue = (inputs[0] && inputs[1]) ? 0 : 1;
                            break;
                        case 'NOR':
                            newValue = (inputs[0] || inputs[1]) ? 0 : 1;
                            break;
                        case 'XOR':
                            newValue = (inputs[0] !== inputs[1]) ? 1 : 0;
                            break;
                        case 'OUTPUT':
                            newValue = inputs[0];
                            break;
                    }

                    if (newValue !== comp.value) {
                        comp.value = newValue;
                        changed = true;
                    }
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.width; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i < canvas.height; i += 50) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            for (let wire of wires) {
                const from = getConnectionPoint(wire.from, true);
                const to = getConnectionPoint(wire.to, false, wire.toIndex);
                const value = wire.from.value;
                
                ctx.strokeStyle = value === 1 ? '#2ecc71' : value === 0 ? '#e74c3c' : '#666';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();
            }

            if (wireStart && wireDragPos) {
                const from = getConnectionPoint(wireStart.component, true);
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(wireDragPos.x, wireDragPos.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            for (let comp of components) {
                const isHovered = comp === hoveredComponent;
                if (comp.type === 'INPUT') {
                    drawInput(comp, isHovered);
                } else if (comp.type === 'OUTPUT') {
                    drawOutput(comp, isHovered);
                } else {
                    drawGate(comp, isHovered);
                }
            }
        }

        function drawInput(comp, isHovered) {
            const color = comp.value === 1 ? '#2ecc71' : '#e74c3c';
            
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(comp.x, comp.y, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = isHovered ? '#f39c12' : '#fff';
            ctx.lineWidth = isHovered ? 4 : 2;
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(comp.value, comp.x, comp.y);

            const output = getConnectionPoint(comp, true);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(output.x, output.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.font = '14px Arial';
            ctx.fillText('INPUT', comp.x, comp.y + 35);
        }

        function drawOutput(comp, isHovered) {
            const isOn = comp.value === 1;
            const color = isOn ? '#2ecc71' : '#555';
            
            // Draw hexagon shape
            ctx.fillStyle = color;
            ctx.strokeStyle = isHovered ? '#f39c12' : '#fff';
            ctx.lineWidth = isHovered ? 4 : 2;
            
            ctx.beginPath();
            const size = 20;
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = comp.x + size * Math.cos(angle);
                const y = comp.y + size * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Draw glow effect when on
            if (isOn) {
                ctx.shadowColor = '#2ecc71';
                ctx.shadowBlur = 20;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = comp.x + size * Math.cos(angle);
                    const y = comp.y + size * Math.sin(angle);
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.shadowBlur = 0;
            }

            // Draw value
            ctx.fillStyle = isOn ? '#000' : '#fff';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(comp.value !== null ? comp.value : '?', comp.x, comp.y);

            // Draw input connection point
            const input = getConnectionPoint(comp, false);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(input.x, input.y, 5, 0, Math.PI * 2);
            ctx.fill();

            ctx.font = '14px Arial';
            ctx.fillStyle = '#fff';
            ctx.fillText('OUTPUT', comp.x, comp.y + 35);
        }

        function drawGate(comp, isHovered) {
            const color = comp.value === 1 ? '#2ecc71' : comp.value === 0 ? '#e74c3c' : '#555';
            
            ctx.fillStyle = '#2c3e50';
            ctx.strokeStyle = isHovered ? '#f39c12' : color;
            ctx.lineWidth = isHovered ? 4 : 3;
            ctx.fillRect(comp.x - 40, comp.y - 25, 80, 50);
            ctx.strokeRect(comp.x - 40, comp.y - 25, 80, 50);

            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(comp.type, comp.x, comp.y - 5);

            if (comp.value !== null) {
                ctx.font = 'bold 16px Arial';
                ctx.fillText(comp.value, comp.x, comp.y + 12);
            }

            ctx.fillStyle = '#fff';
            
            const output = getConnectionPoint(comp, true);
            ctx.beginPath();
            ctx.arc(output.x, output.y, 5, 0, Math.PI * 2);
            ctx.fill();

            const numInputs = comp.type === 'NOT' ? 1 : 2;
            for (let i = 0; i < numInputs; i++) {
                const input = getConnectionPoint(comp, false, i);
                ctx.beginPath();
                ctx.arc(input.x, input.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        draw();
    </script>
</body>
</html>